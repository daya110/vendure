import { AdminUiExtension, AdminUiExtensionModule } from '@vendure/common/lib/shared-types';
import * as fs from 'fs-extra';
import * as path from 'path';

const EXTENSIONS_DIR = path.join(__dirname, '../src/app/extensions');
const EXTENSIONS_MODULES_DIR = 'modules';
const lazyExtensionsModuleFile = path.join(EXTENSIONS_DIR, 'lazy-extensions.module.ts');
const sharedExtensionsModuleFile = path.join(EXTENSIONS_DIR, 'shared-extensions.module.ts');

/**
 * Returns true if currently being executed from inside the Vendure monorepo.
 */
export function isInVendureMonorepo(): boolean {
    return fs.existsSync(path.join(__dirname, '../../dev-server'));
}

/**
 * Deletes the contents of the /modules directory, which contains the plugin
 * extension modules copied over during the last compilation.
 */
export function deleteExistingExtensionModules() {
    fs.removeSync(path.join(EXTENSIONS_DIR, EXTENSIONS_MODULES_DIR));
}

/**
 * Copies all files from the extensionPaths of the configured extensions into the
 * admin-ui source tree.
 */
export function copyExtensionModules(extensions: Array<Required<AdminUiExtension>>) {
    for (const extension of extensions) {
        const dirName = path.basename(path.dirname(extension.extensionPath));
        const dest = getModuleOutputDir(extension);
        fs.copySync(extension.extensionPath, dest);
    }
}

export function getModuleOutputDir(extension: Required<AdminUiExtension>): string {
    return path.join(EXTENSIONS_DIR, EXTENSIONS_MODULES_DIR, extension.id);
}

export function createExtensionsModules(extensions: Array<Required<AdminUiExtension>>) {
    const removeTsExtension = (filename: string): string => filename.replace(/\.ts$/, '');
    const importPath = (id: string, fileName: string): string =>
        `./${EXTENSIONS_MODULES_DIR}/${id}/${removeTsExtension(fileName)}`;

    for (const type of ['lazy', 'shared'] as const) {
        const modulesOfType = extensions
            .reduce(
                (modules, e) => [...modules, ...e.ngModules.map(m => ({ id: e.id, module: m }))],
                [] as Array<{ id: string; module: AdminUiExtensionModule }>,
            )
            .filter(m => m.module.type === type)
            .map(e => ({
                className: e.module.ngModuleName,
                path: importPath(e.id, e.module.ngModuleFileName),
            }));
        const source = generateExtensionModuleTsSource(type, modulesOfType);
        const filePath = type === 'lazy' ? lazyExtensionsModuleFile : sharedExtensionsModuleFile;
        fs.writeFileSync(filePath, source, 'utf-8');
    }
}

export function restoreOriginalExtensionsModule() {
    restoreExtensionsModules();
}

/**
 * Restores the placeholder ExtensionsModule file from a template.
 */
export function restoreExtensionsModules() {
    for (const type of ['lazy', 'shared'] as const) {
        const source = generateExtensionModuleTsSource(type, []);
        const filePath = type === 'lazy' ? lazyExtensionsModuleFile : sharedExtensionsModuleFile;
        fs.writeFileSync(filePath, source, 'utf-8');
    }
}

function generateExtensionModuleTsSource(
    type: 'shared' | 'lazy',
    modules: Array<{ className: string; path: string }>,
): string {
    return `/** This file is generated by the createExtensionsModules() function in devkit/common.ts. Do not edit. */
import { CommonModule } from '@angular/common';
import { NgModule } from '@angular/core';

${modules.map(e => `import { ${e.className} } from '${e.path}';`).join('\n')}

/**
 * This is a placeholder module for UI extensions provided by the AdminUiPlugin \`extensions\` option.
 * When the {@link createExtensionsModules} function is executed, this module gets temporarily replaced
 * by a generated module which includes all of the configured extension modules.
 */
@NgModule({
    imports: [
        CommonModule,
        ${modules.map(e => e.className + ',').join('\n')}
    ],
})
export class ${type === 'lazy' ? 'Lazy' : 'Shared'}ExtensionsModule {}
`;
}
