import { AdminUiExtension, AdminUiExtensionModule } from '@vendure/common/lib/shared-types';
import * as fs from 'fs-extra';
import * as path from 'path';

const EXTENSIONS_DIR = path.join(__dirname, '../src/app/extensions');
const EXTENSIONS_MODULES_DIR = 'modules';
const STATIC_ASSETS_OUTPUT_DIR = path.join(EXTENSIONS_DIR, '__static-assets__');
const lazyExtensionsModuleFile = path.join(EXTENSIONS_DIR, 'lazy-extensions.module.ts');
const sharedExtensionsModuleFile = path.join(EXTENSIONS_DIR, 'shared-extensions.module.ts');

/**
 * Returns true if currently being executed from inside the Vendure monorepo.
 */
export function isInVendureMonorepo(): boolean {
    return fs.existsSync(path.join(__dirname, '../../dev-server'));
}

/**
 * Deletes the contents of the /modules directory, which contains the plugin
 * extension modules copied over during the last compilation.
 */
export function deleteExistingExtensionModules() {
    fs.removeSync(path.join(EXTENSIONS_DIR, EXTENSIONS_MODULES_DIR));
    fs.removeSync(STATIC_ASSETS_OUTPUT_DIR);
}

/**
 * Copies all files from the extensionPaths of the configured extensions into the
 * admin-ui source tree.
 */
export function copyExtensionModules(extensions: Array<Required<AdminUiExtension>>) {
    for (const extension of extensions) {
        const dirName = path.basename(path.dirname(extension.extensionPath));
        const dest = getModuleOutputDir(extension);
        fs.copySync(extension.extensionPath, dest);
        if (Array.isArray(extension.staticAssets)) {
            for (const asset of extension.staticAssets) {
                copyStaticAsset(asset);
            }
        }
    }
}

/**
 * Copy the @vendure/ui-devkit files to the static assets dir.
 */
export function copyUiDevkit() {
    const devkitDir = path.join(STATIC_ASSETS_OUTPUT_DIR, 'devkit');
    fs.ensureDirSync(devkitDir);
    fs.copySync(require.resolve('@vendure/ui-devkit'), path.join(devkitDir, 'ui-devkit.js'));
}

/**
 * Copies over any files defined by the extensions' `staticAssets` array to the shared
 * static assets directory. When the app is built by the ng cli, this assets directory is
 * the copied over to the final static assets location (i.e. http://domain/admin/assets/)
 */
export function copyStaticAsset(staticAssetPath: string) {
    const stats = fs.statSync(staticAssetPath);
    if (stats.isDirectory()) {
        const assetDirname = path.basename(staticAssetPath);
        fs.copySync(staticAssetPath, path.join(STATIC_ASSETS_OUTPUT_DIR, assetDirname));
    } else {
        fs.copySync(staticAssetPath, STATIC_ASSETS_OUTPUT_DIR);
    }
}

export function getModuleOutputDir(extension: Required<AdminUiExtension>): string {
    return path.join(EXTENSIONS_DIR, EXTENSIONS_MODULES_DIR, extension.id);
}

export function createExtensionsModules(extensions: Array<Required<AdminUiExtension>>) {
    const removeTsExtension = (filename: string): string => filename.replace(/\.ts$/, '');
    const importPath = (id: string, fileName: string): string =>
        `./${EXTENSIONS_MODULES_DIR}/${id}/${removeTsExtension(fileName)}`;

    for (const type of ['lazy', 'shared'] as const) {
        const modulesOfType = extensions
            .reduce(
                (modules, e) => [...modules, ...e.ngModules.map(m => ({ id: e.id, module: m }))],
                [] as Array<{ id: string; module: AdminUiExtensionModule }>,
            )
            .filter(m => m.module.type === type)
            .map(e => ({
                className: e.module.ngModuleName,
                path: importPath(e.id, e.module.ngModuleFileName),
            }));
        const source = generateExtensionModuleTsSource(type, modulesOfType);
        const filePath = type === 'lazy' ? lazyExtensionsModuleFile : sharedExtensionsModuleFile;
        fs.writeFileSync(filePath, source, 'utf-8');
    }
}

export function restoreOriginalExtensionsModule() {
    restoreExtensionsModules();
}

/**
 * Restores the placeholder ExtensionsModule file from a template.
 */
export function restoreExtensionsModules() {
    for (const type of ['lazy', 'shared'] as const) {
        const source = generateExtensionModuleTsSource(type, []);
        const filePath = type === 'lazy' ? lazyExtensionsModuleFile : sharedExtensionsModuleFile;
        fs.writeFileSync(filePath, source, 'utf-8');
    }
}

function generateExtensionModuleTsSource(
    type: 'shared' | 'lazy',
    modules: Array<{ className: string; path: string }>,
): string {
    return `/** This file is generated by the createExtensionsModules() function in devkit/common.ts. Do not edit. */
import { CommonModule } from '@angular/common';
import { NgModule } from '@angular/core';
${
    modules.length === 0
        ? ''
        : '\n' + modules.map(e => `import { ${e.className} } from '${e.path}';`).join('\n')
}
/**
 * This is a placeholder module for UI extensions provided by the AdminUiPlugin \`extensions\` option.
 * When the {@link createExtensionsModules} function is executed, this module gets temporarily replaced
 * by a generated module which includes all of the configured extension modules.
 */
@NgModule({
    imports: [
        CommonModule,${
            modules.length === 0 ? '' : '\n' + modules.map(e => '        ' + e.className + ',').join('\n')
        }
    ],
})
export class ${type === 'lazy' ? 'Lazy' : 'Shared'}ExtensionsModule {}
`;
}
